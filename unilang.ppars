{
  #include "ast.h"
  #include "unilang_lexer.h"
  #include "parser_helper.h"
}

identifier: {IDENTIFIER} => {
  token_t *ptr = %{0%};
  ast_t *res = new_identifier(*ptr);
  free(ptr);
  return res;
}

intlit: {INTLIT} => {
  token_t *ptr = %{0%};
  ast_t *res = new_intlit(*ptr);
  free(ptr);
  return res;
}

floatlit: {FLOATLIT} => {
  token_t *ptr = %{0%};
  ast_t *res = new_floatlit(*ptr);
  free(ptr);
  return res;
}

charlit: {CHARLIT} => {
  token_t *ptr = %{0%};
  ast_t *res = new_charlit(*ptr);
  free(ptr);
  return res;
}

stringlit: {STRLIT} => {
    token_t *ptr = %{0%};
    ast_t *res = new_stringlit(*ptr);
    free(ptr);
    return res;
  }

boollit: 
  | 'true' => { return new_boollit(1);}
  | 'false' => { return new_boollit(0);}

literal: 
  | %intlit => { return %{0%}; }
  | %floatlit => { return %{0%}; }
  | %charlit => { return %{0%}; }
  | %stringlit => { return %{0%}; }

param: %identifier ':' %type => {
  ast_t *id = %{0%};
  ast_t *type = %{2%};
  return new_param(id, type);
}

arglist: @list elem=%param separator=','

funcall: %identifier '(' %funcallargs ')' => {
  ast_t *iden = %{0%};
  ast_t ** elems = %{2%};
  token_t name = iden->as.identifier.tok;
  free_ast(iden);
  size_t i = 0;
  while(elems[i]){
    i++;
  }
  elems = realloc(elems, sizeof(ast_t *) * i);
  return new_funcall(name, i, elems); 
}

funcallargs: @list elem=%expr separator=','

leaf:
  | %paren => { return %{0%}; }
  | %funcall => { return %{0%}; }
  | %literal => { return %{0%}; }
  | %identifier => { return %{0%}; }

expr:
  | %binop => { return %{0%}; }
  | %leaf => { return %{0%}; }

stmt: 
  | %expr ';' => { return %{0%}; }
  | %compound => { return %{0%}; }

decl:
  | %fundef => { return %{0%}; }

binop: => {
  *worked = 1;
  ast_t *res = parse_expression_aux(l, -1);
  if(!res) *worked = 0;
  return res;
}

paren: '(' %expr ')' => {
  return %{1%};
}

starlist: @list elem='*'

type: 
  | %identifier %starlist => {
    ast_t * iden = %{0%};
    token_t **starlist = %{1%};
    size_t count = 0;
    while(starlist[count]){
      count++;
    }
    for(size_t i = 0; i < count; ++i){
      free(starlist[i]);
    }
    free(starlist);
    token_t tok = iden->as.identifier.tok;
    free_ast(iden);
    return new_type(tok, count);
  }
  | %identifier => {
    ast_t *iden = %{0%};
    token_t tok = iden->as.identifier.tok;
    free_ast(iden);
    return new_type(tok, 0);
  }

unary: %uop %leaf => {
  token_t *ptr = %{0%};
  ast_t *leaf = %{1%}; 
  ast_t *res = new_unop(*ptr, leaf);
  return res;
}

stmt_list: @list elem=%stmt

compound: 
  | '{' '}' => {
    ast_t **res = malloc(sizeof(ast_t *));
    *res = NULL;
    return new_compound(res);
  }
  | '{' %stmt_list '}' => { return new_compound(%{1%}); }


program_list: @list elem=%decl

program: %program_list => {
  return new_compound(%{0%});
}

fundef: 
  | 'let' %identifier '(' %arglist ')' '=>' %compound => {
    ast_t *id = %{1%};
    tmp_param_t **tmp_arglist = %{3%};
    ast_t *stmt_list = %{6%};
    token_t tok = id->as.identifier.tok;
    free_ast(id);
    return new_fundef_from_parser(tok, tmp_arglist, stmt_list);
  }
  | 'let' %identifier '(' ')' '=>' %compound => {
    ast_t *id = %{1%};
    tmp_param_t **tmp_arglist = malloc(sizeof(void*));
    tmp_arglist[0] = NULL;
    ast_t *stmt_list = %{5%};
    token_t tok = id->as.identifier.tok;
    free_ast(id);
    return new_fundef_from_parser(tok, tmp_arglist, stmt_list);
  }

uop: 
  | '-' => { return %{0%}; }
  | 'not' => { return %{0%}; }
