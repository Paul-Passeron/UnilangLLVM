{
  #include <stdint.h>
  #include "ast.h"
  #include "unilang_lexer.h"
  #include "parser_helper.h"
}

identifier: {IDENTIFIER} => {
  token_t *ptr = %{0%};
  ast_t *res = new_identifier(*ptr);
  free(ptr);
  return res;
}

intlit: {INTLIT} => {
  token_t *ptr = %{0%};
  ast_t *res = new_intlit(*ptr);
  free(ptr);
  return res;
}

floatlit: {FLOATLIT} => {
  token_t *ptr = %{0%};
  ast_t *res = new_floatlit(*ptr);
  free(ptr);
  return res;
}

charlit: {CHARLIT} => {
  token_t *ptr = %{0%};
  ast_t *res = new_charlit(*ptr);
  free(ptr);
  return res;
}

stringlit: {STRLIT} => {
    token_t *ptr = %{0%};
    ast_t *res = new_stringlit(*ptr);
    free(ptr);
    return res;
  }

boollit: 
  | 'true' => { return new_boollit(1);}
  | 'false' => { return new_boollit(0);}

literal: 
  | %intlit => { return %{0%}; }
  | %floatlit => { return %{0%}; }
  | %charlit => { return %{0%}; }
  | %stringlit => { return %{0%}; }

param: %identifier ':' %type => {
  ast_t *id = %{0%};
  ast_t *type = %{2%};
  return new_param(id, type);
}

arglist: @list elem=%param separator=','

funcall: %identifier '(' %funcallargs ')' => {
  ast_t *iden = %{0%};
  ast_t ** elems = %{2%};
  token_t name = iden->as.identifier.tok;
  free_ast(iden);
  size_t i = 0;
  while(elems[i]){
    i++;
  }
  elems = realloc(elems, sizeof(ast_t *) * i);
  return new_funcall(name, i, elems); 
}

funcallargs: @list elem=%expr separator=','

leaf:
  | %paren => { return %{0%}; }
  | %funcall => { return %{0%}; }
  | %literal => { return %{0%}; }
  | %identifier => { return %{0%}; }

expr:
  | %binop => { return %{0%}; }
  | %leaf => { return %{0%}; }

stmt: 
  | %expr ';' => { return %{0%}; }
  | %compound => { return %{0%}; }
  | %vardef => { return %{0%}; }
decl:
  | %ct_cte => { return %{0%}; }
  | %fundef => { return %{0%}; }
  | %vardef => { return %{0%}; }
  | %class_decl => { return %{0%}; }

binop: => {
  *worked = 1;
  ast_t *res = parse_expression_aux(l, -1);
  if(!res) *worked = 0;
  return res;
}

paren: '(' %expr ')' => {
  return %{1%};
}

starlist: @list elem='*'

type: 
  | %identifier %starlist => {
    ast_t * iden = %{0%};
    token_t **starlist = %{1%};
    size_t count = 0;
    while(starlist[count]){
      count++;
    }
    fprintf(stderr, "count: %d\n", (int)count);
    for(size_t i = 0; i < count; ++i){
      free(starlist[i]);
    }
    free(starlist);
    token_t tok = iden->as.identifier.tok;
    free_ast(iden);
    return new_type(tok, count);
  }
  | %identifier => {
    ast_t *iden = %{0%};
    token_t tok = iden->as.identifier.tok;
    free_ast(iden);
    return new_type(tok, 0);
  }

unary: %uop %leaf => {
  token_t *ptr = %{0%};
  ast_t *leaf = %{1%}; 
  ast_t *res = new_unop(*ptr, leaf);
  return res;
}

stmt_list: @list elem=%stmt

compound: 
  | '{' '}' => {
    ast_t **res = malloc(sizeof(ast_t *));
    *res = NULL;
    return new_compound(res);
  }
  | '{' %stmt_list '}' => { return new_compound(%{1%}); }


program_list: @list elem=%decl

program: %program_list => {
  return new_compound(%{0%});
}

fundef_letless: 
  | %identifier '(' %arglist ')' ':' %type '=>' %compound => {
    ast_t *id = %{0%};
    ast_t *type = %{5%};
    tmp_param_t **tmp_arglist = %{2%};
    ast_t *stmt_list = %{7%};
    token_t tok = id->as.identifier.tok;
    free_ast(id);
    return new_fundef_from_parser(tok, tmp_arglist, stmt_list, type);
  }
  | %identifier '(' ')' ':' %type '=>' %compound => {
    ast_t *id = %{0%};
    ast_t *type = %{5%};
    tmp_param_t **tmp_arglist = malloc(sizeof(void*));
    tmp_arglist[0] = NULL;
    ast_t *stmt_list = %{6%};
    token_t tok = id->as.identifier.tok;
    free_ast(id);
    return new_fundef_from_parser(tok, tmp_arglist, stmt_list, type);
  }

fundef: 'let' %fundef_letless => { return %{0%}; }

uop: 
  | '-' => { return %{0%}; }
  | '!' => { return %{0%}; }


vardef_letless: 
  | %identifier ':' %type '=>' %expr => {
    ast_t *iden = %{0%};
    token_t tok = iden->as.identifier.tok;
    free(iden);
    return new_vardef(tok, %{2%}, %{4%});
  } 
  | %identifier ':' %type => {
    ast_t *iden = %{0%};
    token_t tok = iden->as.identifier.tok;
    free(iden);
    return new_vardef(tok, %{2%}, NULL);
  } 

vardef: 'let' %vardef_letless ';' => { return %{1%}; }

ct_cte: '@const' {IDENTIFIER} %expr ';' => {
  token_t *iden_ptr = %{1%};
  token_t iden = *iden_ptr;
  free(iden_ptr);
  ast_t *expr = %{2%};
  return new_ct_cte(iden, expr);
}

access_spec: 
  | 'public' => { return %{0%}; }
  | 'private' => { return %{0%}; }
  
abstract_opt:
  | 'abstract' => {
    return %{0%};
  }
  | => {
    *worked = 1;
    (void)l;
    return NULL;
  }

class_body: @list elem=%class_body_item separator=','

class_body_item: 
  | %abstract_opt %access_spec %fundef_letless => {
    uintptr_t abstract_opt = (uintptr_t)%{0%};
    token_t *access_spec_ptr = %{1%};
    token_t access_spec = *access_spec_ptr;
    free(access_spec_ptr);
    ast_t *fundef = %{2%};
    return new_method(fundef, access_spec, abstract_opt != 0);
  }
  | %access_spec %vardef_letless => {
    // for the moment; fix it later
    return %{1%};
  }

class_decl: 'class' %identifier '=>' '{' %class_body '}' => {
  ast_t *iden = %{1%};
  token_t name = iden->as.identifier.tok;
  free_ast(iden);
  ast_t **body = %{4%};
  size_t count = 0;
  while(body[count]){
    count++;
  }
  return new_class(name, count, body);
}

