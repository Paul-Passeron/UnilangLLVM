{
  #include "ast.h"
  #include "unilang_lexer.h"
  #include "parser_helper.h"
}

identifier: {IDENTIFIER} => {
  token_t *ptr = %{0%};
  ast_t *res = new_identifier(*ptr);
  free(ptr);
  return res;
}

intlit: {INTLIT} => {
  token_t *ptr = %{0%};
  ast_t *res = new_intlit(*ptr);
  free(ptr);
  return res;
}

floatlit: {FLOATLIT} => {
  token_t *ptr = %{0%};
  ast_t *res = new_floatlit(*ptr);
  free(ptr);
  return res;
}

charlit: {CHARLIT} => {
  token_t *ptr = %{0%};
  ast_t *res = new_charlit(*ptr);
  free(ptr);
  return res;
}

stringlit: {STRLIT} => {
    token_t *ptr = %{0%};
    ast_t *res = new_stringlit(*ptr);
    free(ptr);
    return res;
  }

boollit: 
  | 'true' => { return new_boollit(1);}
  | 'false' => { return new_boollit(0);}

literal: 
  | %intlit => { return %{0%}; }
  | %floatlit => { return %{0%}; }
  | %charlit => { return %{0%}; }
  | %stringlit => { return %{0%}; }

param: %identifier ':' %identifier => {
  ast_t *id = %{0%};
  ast_t *type = %{2%};
  return new_param(id, type);
}

arglist: @list elem=%param separator=','

/* This comment is important, removing it will break things... (why ?) */

funcall: %identifier '(' %funcallargs ')' => {
  ast_t *iden = %{0%};
  ast_t ** elems = %{2%};
  token_t name = iden->as.identifier.tok;
  free_ast(iden);
  size_t i = 0;
  while(elems[i]){
    i++;
  }
  elems = realloc(elems, sizeof(ast_t *) * i);
  return new_funcall(name, i, elems); 
}

funcallargs: @list elem=%expr separator=','

leaf:
  | %paren => { return %{0%}; }
  | %funcall => { return %{0%}; }
  | %literal => { return %{0%}; }
  | %identifier => { return %{0%}; }

/*
*/

expr:
  | %binop => { return %{0%}; }
  | %leaf => { return %{0%}; }

stmt: 
  | %expr ';' => { return %{0%}; }

decl:
  | %fundef => { return %{0%}; }

binop: => {
  *worked = 1;
  ast_t *res = parse_expression_aux(l, -1);
  if(!res) *worked = 0;
  return res;
}

paren: '(' %expr ')' => {
  return %{1%};
}



unary: %uop %leaf => {
  token_t *ptr = %{0%};
  ast_t *leaf = %{1%}; 
  ast_t *res = new_unop(*ptr, leaf);
  return res;
}

stmt_list: @list elem=%stmt

/**/
program_list: @list elem=%decl

program: %program_list => {
  return new_compound(%{0%});
}

fundef: 'let' %identifier '(' %arglist ')' '=>' '{' %stmt_list '}' => {
  ast_t *id = %{1%};
  tmp_param_t **tmp_arglist = %{3%};
  ast_t **stmt_list = %{7%};
  token_t tok = id->as.identifier.tok;
  free_ast(id);
  return new_fundef_from_parser(tok, tmp_arglist, stmt_list);
}


uop: 
  | '-' => { return %{0%}; }
  | 'not' => { return %{0%}; }

/**/
