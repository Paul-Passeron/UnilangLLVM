@include std::sys
@include std::string

interface any t => {}

class <T impl any> vector => {
  private arr: T*,
  private count: int,
  private cap: int,
  public vector() => {
    self::count => 0;
    self::cap => 16;
    self::arr => malloc(self::cap * @size T);
  },
  public at(i: int): T => {
    if i < (self::count) => {
      return @new T (self::arr[i]);
    }
    (@as string "Could not access element at index " + i + " out of " + (self::count - 1))::println();
    exit(1);
  },
  public append(elem: T): void => {
    if self::count + 1 >= (self::cap) => {
      self::cap => self::cap * 2;
      let old_elems: T * => self::arr;
      self::arr => malloc(self::cap * @size T);
      let i: int => 0;
      while i < (self::count) => {
        self::arr[i] => old_elems[i];
        i => i + 1;
      }
      free(old_elems);
    }
    self::arr[self::count] => elem;
    self::count => self::count + 1;
  },
  public destroy(): void => {
    free(self::arr);
    // TODO: introduce @destroy directive that
    // destroys value if it is a class
    // but does nothing otherwise
    // So that there can be no memory
    // leaks when creating vectors of any
    // without having to manually manage the memory
    // Maybe @destroy on a ptr can just free it as
    // well
    self::count => 0;
    self::cap => 0;
    self::arr => 0;
  },
  public len(): int => {
    return self::count;
  }
}

// class <T impl any>tree => {
//   public value: T,
//   public children: vector<tree<T>*>,
//   public tree(val: T) => {
//     print("TODO: tree\n");
//     exit(1);
//   },
//   public tree(val: T, children: vector<tree<T>*>) => {
//     print("TODO: tree\n");
//     exit(1);
//   }
// }

class <T impl any> rec => {
    public next: rec<T>*,
    public rec() => {
        self::next => @as T * 0;
    }
}

let main(): int => {
  let t: rec<int>;
  return 0;
}
